// This file was auto-generated by Chameleon

/***** DEPENDENCIES *****/

#include <stdlib.h>
#include <stdint.h>

/***** MACROS *****/

#undef UNLIKELY
#define UNLIKELY(x) __builtin_expect(!!(x), 0)
#undef LIKELY
#define LIKELY(x) __builtin_expect(!!(x), 1)

#undef THREAD_LOCAL
#ifdef CHAMELEON_THREAD_SAFE
#define THREAD_LOCAL __thread
#else
#define THREAD_LOCAL
#endif

#undef EXPORT_FUNCTION
#ifdef CHAMELEON_VISIBLE
#define EXPORT_FUNCTION __attribute__((visibility ("default")))
#else
#define EXPORT_FUNCTION
#endif

#ifndef CHAMELEON_SEED
 #define CHAMELEON_SEED 1739639165216539016ULL
#endif

/***** TYPES *****/

typedef struct {
    unsigned int* steps;
    size_t length;
    size_t capacity;
} ChameleonWalk;

/***** PRNG *****/

static THREAD_LOCAL size_t rand_state = STATIC_SEED;

static inline size_t random (void) {
    size_t x = rand_state;
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    return rand_state = x;
}

/***** TERMINALS *****/

{% for (id, content) in grammar.terminals() -%}
static const unsigned char TERMINAL_{{ id }}[{{ content.len() }}] = {
    {% for byte in content -%}
        {{ "{:#02x}" | format(byte) }}
        {%- if !loop.last %},{% endif %}
    {%- endfor %}
};
{% endfor %}

/***** FUNCTIONS *****/

#if !defined(OMIT_CHAMELEON_MUTATE) || !defined(OMIT_CHAMELEON_GENERATE)
{% for (id, _) in grammar.nonterminals() %}
static size_t _mutate_nonterm_{{ id }} (unsigned int*, const size_t, const size_t, size_t*, unsigned char*, size_t);
{%- endfor %}

{% for (id, numberset) in grammar.numbersets() %}
static void _mutate_numberset_{{ id }} (unsigned char* output) {
    size_t idx = random() % {{ numberset.set().len() }};
    uint64_t value;
    
    switch (idx) {
        {%- for (i, range) in numberset.set().iter().enumerate() %}
        case {{ i }}: {
            value = {{ range.start() }}ULL + (random() % ({{ range.end() }}ULL - {{ range.start() }}ULL + 1));
            break;
        }
        {%- endfor %}
        default: {
            __builtin_unreachable();
        }
    }
    
    __builtin_memcpy(output, (unsigned char*) &value, sizeof({{ numberset.typ().c_type() }}));
}
{%- endfor %}
{% for set in grammar.rules() %}
// This is the mutation function for non-terminal '{{ grammar.nonterminal(set.nonterm().id()) }}'
static size_t _mutate_nonterm_{{ set.nonterm().id() }} (unsigned int* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    size_t r;
    unsigned int mutate, rule;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return 0;
    }
    *step = s + 1;
    
    mutate = (s >= length);
    
    if (mutate) {
        rule = random() % {{ set.rules().len() }};
        steps[s] = rule;
    } else {
        rule = steps[s];
    }
    
    switch (rule) {
        {%- for (i, rule) in set.rules().iter().enumerate() %}
        case {{ i }}: {
            {%- for symbol in rule %}
            {%- match symbol %}
            {%- when crate::translator::Symbol::Terminal(term) %}
            {%- match term %}
            {%- when crate::translator::Terminal::Numberset(id) %}
            {%- let numberset = grammar.numberset(**id) %}
            if (mutate) {
                if (UNLIKELY(sizeof({{ numberset.typ().c_type() }}) > output_length)) {
                    return output_length;
                }
                _mutate_numberset_{{ id }}(output);
            }
            output += sizeof({{ numberset.typ().c_type() }});
            output_length -= sizeof({{ numberset.typ().c_type() }});
            {%- when crate::translator::Terminal::Bytes(id) %}
            if (mutate) {
                if (UNLIKELY(sizeof(TERMINAL_{{ id }}) > output_length)) {
                    return output_length;
                }
                __builtin_memcpy(output, TERMINAL_{{ id }}, sizeof(TERMINAL_{{ id }}));
            }
            output += sizeof(TERMINAL_{{ id }});
            output_length -= sizeof(TERMINAL_{{ id }});
            {%- endmatch %}
            {%- when crate::translator::Symbol::NonTerminal(nonterm) %}
            r = _mutate_nonterm_{{ nonterm.id() }}(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            {%- endmatch %}
            {%- endfor %}
            break;
        }
        {% endfor %}
        default: {
            __builtin_unreachable();
        }
    }
    
    return (size_t) (output - original_output);
}
{% endfor %}
#endif /* !defined(OMIT_CHAMELEON_MUTATE) || !defined(OMIT_CHAMELEON_GENERATE) */

#ifndef OMIT_CHAMELEON_SEED
EXPORT_FUNCTION
void chameleon_seed (size_t new_seed) {
    rand_state = new_seed;
}
#endif /* OMIT_CHAMELEON_SEED */

#ifndef OMIT_CHAMELEON_INIT
EXPORT_FUNCTION
void chameleon_init (ChameleonWalk* walk, size_t capacity) {
    walk->steps = malloc(capacity * sizeof(unsigned int));
    walk->length = 0;
    walk->capacity = capacity;
}
#endif /* OMIT_CHAMELEON_INIT */

#ifndef OMIT_CHAMELEON_DESTROY
EXPORT_FUNCTION
void chameleon_destroy (ChameleonWalk* walk) {
    free(walk->steps);
    __builtin_memset(walk, 0, sizeof(ChameleonWalk));
}
#endif /* OMIT_CHAMELEON_DESTROY */

#ifndef OMIT_CHAMELEON_MUTATE
EXPORT_FUNCTION
size_t chameleon_mutate (ChameleonWalk* walk, unsigned char* output, size_t output_length) {
    size_t length = 0;
    if (LIKELY(walk->length > 0)) {
        length = random() % walk->length;
    }
    walk->length = 0;
    return _mutate_nonterm_{{ grammar.entrypoint().id() }}(walk->steps, length, walk->capacity, &walk->length, output, output_length);
}
#endif /* OMIT_CHAMELEON_MUTATE */

#ifndef OMIT_CHAMELEON_GENERATE
EXPORT_FUNCTION
size_t chameleon_generate (ChameleonWalk* walk, unsigned char* output, size_t output_length) {
    walk->length = 0;
    return _mutate_nonterm_{{ grammar.entrypoint().id() }}(walk->steps, 0, walk->capacity, &walk->length, output, output_length);
}
#endif /* OMIT_CHAMELEON_GENERATE */
