// This file was auto-generated by Chameleon
//
// How to use:
//
// 1) You can either compile this code into a shared object
//    that can be loaded by Chameleon's LibAFL components:
//    $ gcc -O3 -flto -march=native -fno-stack-protector -fomit-frame-pointer -fvisibility=hidden -DCHAMELEON_VISIBLE -fPIC -shared -o mutator.so <source file>
//
// 2) Or, you can directly integrate this code into one of your projects. See include/chameleon.h for all of the
//    functions you can use.
//
// Quick API overview:
//
// Macros:
//  - CHAMELEON_THREAD_SAFE: Define this to make the code thread-safe
//  - CHAMELEON_VISIBLE: Define this to set visibility to default on chameleon_* functions
//  - CHAMELEON_SEED: The static seed compiled into the code
//  - OMIT_CHAMELEON_MUTATE: Do not include the chameleon_mutate() code
//  - OMIT_CHAMELEON_GENERATE: Do not include the chameleon_generate() code
//  - OMIT_CHAMELEON_SEED: Do not include chameleon_seed()
//  - OMIT_CHAMELEON_INIT: Do not include chameleon_init()
//  - OMIT_CHAMELEON_DESTROY: Do not include chameleon_destroy()
//
// Functions:
//  - chameleon_seed(): Supply a seed to the internal PRNG
//  - chameleon_init(): Initialize a ChameleonWalk
//  - chameleon_destroy(): Deinit a ChameleonWalk
//  - chameleon_mutate(): Given a walk and its associated output, mutate the output according to the grammar rules
//  - chameleon_generate(): Generate a walk and its associated output according to the grammar rules
//

/***** DEPENDENCIES *****/

#include <stdlib.h>
#include <stdint.h>

/***** MACROS *****/

#undef UNLIKELY
#define UNLIKELY(x) __builtin_expect(!!(x), 0)
#undef LIKELY
#define LIKELY(x) __builtin_expect(!!(x), 1)

#undef THREAD_LOCAL
#ifdef CHAMELEON_THREAD_SAFE
#define THREAD_LOCAL __thread
#else
#define THREAD_LOCAL
#endif

#undef EXPORT_FUNCTION
#ifdef CHAMELEON_VISIBLE
#define EXPORT_FUNCTION __attribute__((visibility ("default")))
#else
#define EXPORT_FUNCTION
#endif

#ifndef CHAMELEON_SEED
 #define CHAMELEON_SEED 1739639165216539016ULL
#endif

#define TRIANGULAR_RANDOM(n) (TRIANGULAR_LOOKUP_TABLE[internal_random() % ((n * (n + 1)) >> 1)])
#define LINEAR_RANDOM(n) (internal_random() % n)

/***** TYPES *****/

typedef uint8_t step_t;

typedef struct {
    step_t* steps;
    size_t length;
    size_t capacity;
} ChameleonWalk;

/***** PRNG *****/

static THREAD_LOCAL size_t rand_state = CHAMELEON_SEED;

static inline size_t internal_random (void) {
    size_t x = rand_state;
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    return rand_state = x;
}

static const step_t TRIANGULAR_LOOKUP_TABLE[] = {
0,
1,1,
2,2,2,
3,3,3,3,
4,4,4,4,4,
5,5,5,5,5,5,
};


/***** TERMINALS *****/

static const unsigned char TERMINAL_6[1] = {
    0x5c
};
static const unsigned char TERMINAL_14[1] = {
    0x2b
};
static const unsigned char TERMINAL_19[5] = {
    0x66,0x61,0x6c,0x73,0x65
};
static const unsigned char TERMINAL_7[1] = {
    0x2f
};
static const unsigned char TERMINAL_10[1] = {
    0x6e
};
static const unsigned char TERMINAL_8[1] = {
    0x62
};
static const unsigned char TERMINAL_21[1] = {
    0x3a
};
static const unsigned char TERMINAL_3[1] = {
    0x30
};
static const unsigned char TERMINAL_18[4] = {
    0x74,0x72,0x75,0x65
};
static const unsigned char TERMINAL_0[1] = {
    0x7d
};
static const unsigned char TERMINAL_17[1] = {
    0x5b
};
static const unsigned char TERMINAL_22[1] = {
    0x65
};
static const unsigned char TERMINAL_15[1] = {
    0x2d
};
static const unsigned char TERMINAL_16[1] = {
    0x7b
};
static const unsigned char TERMINAL_1[1] = {
    0x5d
};
static const unsigned char TERMINAL_11[1] = {
    0x72
};
static const unsigned char TERMINAL_13[1] = {
    0x75
};
static const unsigned char TERMINAL_4[1] = {
    0x2c
};
static const unsigned char TERMINAL_9[1] = {
    0x66
};
static const unsigned char TERMINAL_12[1] = {
    0x74
};
static const unsigned char TERMINAL_2[1] = {
    0x22
};
static const unsigned char TERMINAL_5[1] = {
    0x2e
};
static const unsigned char TERMINAL_20[4] = {
    0x6e,0x75,0x6c,0x6c
};
static const unsigned char TERMINAL_23[1] = {
    0x45
};


/***** FUNCTIONS *****/

#if !defined(OMIT_CHAMELEON_MUTATE) || !defined(OMIT_CHAMELEON_GENERATE)

static size_t _mutate_nonterm_10 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_7 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_19 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_9 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_1 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_3 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_17 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_13 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_20 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_15 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_14 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_2 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_6 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_12 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_4 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_11 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_0 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_8 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_18 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_5 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);
static size_t _mutate_nonterm_16 (step_t*, const size_t, const size_t, size_t*, unsigned char*, size_t);


static inline void _numberset_2 (unsigned char* output) {
    uint64_t value = 48ULL + (internal_random() % (57ULL - 48ULL + 1));
    __builtin_memcpy(output, (unsigned char*) &value, sizeof(uint8_t));
}
static inline void _numberset_7 (unsigned char* output) {
    uint64_t value = 49ULL + (internal_random() % (57ULL - 49ULL + 1));
    __builtin_memcpy(output, (unsigned char*) &value, sizeof(uint8_t));
}
static inline void _numberset_6 (unsigned char* output) {
    uint64_t value = 240ULL + (internal_random() % (247ULL - 240ULL + 1));
    __builtin_memcpy(output, (unsigned char*) &value, sizeof(uint8_t));
}
static void _numberset_3 (unsigned char* output) {
    uint64_t value;
    
    switch (LINEAR_RANDOM(3)) {
        case 0: {
            value = 35ULL + (internal_random() % (91ULL - 35ULL + 1));
            break;
        }
        case 1: {
            value = 93ULL + (internal_random() % (127ULL - 93ULL + 1));
            break;
        }
        case 2: {
            value = 32ULL + (internal_random() % (33ULL - 32ULL + 1));
            break;
        }
        default: {
            __builtin_unreachable();
        }
    }
    
    __builtin_memcpy(output, (unsigned char*) &value, sizeof(uint8_t));
}
static inline void _numberset_4 (unsigned char* output) {
    uint64_t value = 192ULL + (internal_random() % (223ULL - 192ULL + 1));
    __builtin_memcpy(output, (unsigned char*) &value, sizeof(uint8_t));
}
static inline void _numberset_1 (unsigned char* output) {
    uint64_t value = 128ULL + (internal_random() % (191ULL - 128ULL + 1));
    __builtin_memcpy(output, (unsigned char*) &value, sizeof(uint8_t));
}
static void _numberset_0 (unsigned char* output) {
    uint64_t value;
    
    switch (LINEAR_RANDOM(3)) {
        case 0: {
            value = 97ULL + (internal_random() % (102ULL - 97ULL + 1));
            break;
        }
        case 1: {
            value = 65ULL + (internal_random() % (70ULL - 65ULL + 1));
            break;
        }
        case 2: {
            value = 48ULL + (internal_random() % (57ULL - 48ULL + 1));
            break;
        }
        default: {
            __builtin_unreachable();
        }
    }
    
    __builtin_memcpy(output, (unsigned char*) &value, sizeof(uint8_t));
}
static inline void _numberset_5 (unsigned char* output) {
    uint64_t value = 224ULL + (internal_random() % (239ULL - 224ULL + 1));
    __builtin_memcpy(output, (unsigned char*) &value, sizeof(uint8_t));
}


// This is the mutation function for non-terminal 'json::OBJECT-END'
static size_t _mutate_nonterm_0 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    size_t r;
    unsigned int mutate;
    step_t rule;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    *step = s + 1;
    
    mutate = (s >= length);
    
    if (mutate) {
        rule = (step_t) TRIANGULAR_RANDOM(2);
        steps[s] = rule;
    } else {
        rule = steps[s];
    }
    
    switch (rule) {
        case 0: {
            if (UNLIKELY(sizeof(TERMINAL_0) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_0, sizeof(TERMINAL_0));
            }
            output += sizeof(TERMINAL_0);
            break;
        }
        
        case 1: {
            if (UNLIKELY(sizeof(TERMINAL_4) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_4, sizeof(TERMINAL_4));
            }
            output += sizeof(TERMINAL_4);
            output_length -= sizeof(TERMINAL_4);
            r = _mutate_nonterm_12(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        default: {
            __builtin_unreachable();
        }
    }
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal 'json::ARRAY-END'
static size_t _mutate_nonterm_1 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    size_t r;
    unsigned int mutate;
    step_t rule;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    *step = s + 1;
    
    mutate = (s >= length);
    
    if (mutate) {
        rule = (step_t) TRIANGULAR_RANDOM(2);
        steps[s] = rule;
    } else {
        rule = steps[s];
    }
    
    switch (rule) {
        case 0: {
            if (UNLIKELY(sizeof(TERMINAL_1) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_1, sizeof(TERMINAL_1));
            }
            output += sizeof(TERMINAL_1);
            break;
        }
        
        case 1: {
            if (UNLIKELY(sizeof(TERMINAL_4) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_4, sizeof(TERMINAL_4));
            }
            output += sizeof(TERMINAL_4);
            output_length -= sizeof(TERMINAL_4);
            r = _mutate_nonterm_13(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        default: {
            __builtin_unreachable();
        }
    }
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal 'json::STRING'
static size_t _mutate_nonterm_2 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    (void) steps;
    size_t r;
    unsigned int mutate;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    mutate = (s >= length);
    
    
    if (UNLIKELY(sizeof(TERMINAL_2) > output_length)) {
        return output_length;
    }
    if (mutate) {   
        __builtin_memcpy(output, TERMINAL_2, sizeof(TERMINAL_2));
    }
    output += sizeof(TERMINAL_2);
    output_length -= sizeof(TERMINAL_2);
    r = _mutate_nonterm_3(steps, length, capacity, step, output, output_length);
    output += r;
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal 'json::STRING-CONTENT'
static size_t _mutate_nonterm_3 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    size_t r;
    unsigned int mutate;
    step_t rule;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    *step = s + 1;
    
    mutate = (s >= length);
    
    if (mutate) {
        rule = (step_t) TRIANGULAR_RANDOM(6);
        steps[s] = rule;
    } else {
        rule = steps[s];
    }
    
    switch (rule) {
        case 0: {
            if (UNLIKELY(sizeof(TERMINAL_2) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_2, sizeof(TERMINAL_2));
            }
            output += sizeof(TERMINAL_2);
            break;
        }
        
        case 1: {
            if (UNLIKELY(sizeof(uint8_t) > output_length)) {
                return output_length;
            }
            if (mutate) {
                _numberset_3(output);
            }
            output += sizeof(uint8_t);
            output_length -= sizeof(uint8_t);
            r = _mutate_nonterm_3(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        case 2: {
            if (UNLIKELY(sizeof(TERMINAL_6) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_6, sizeof(TERMINAL_6));
            }
            output += sizeof(TERMINAL_6);
            output_length -= sizeof(TERMINAL_6);
            r = _mutate_nonterm_10(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_3(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        case 3: {
            if (UNLIKELY(sizeof(uint8_t) > output_length)) {
                return output_length;
            }
            if (mutate) {
                _numberset_4(output);
            }
            output += sizeof(uint8_t);
            output_length -= sizeof(uint8_t);
            r = _mutate_nonterm_19(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_3(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        case 4: {
            if (UNLIKELY(sizeof(uint8_t) > output_length)) {
                return output_length;
            }
            if (mutate) {
                _numberset_5(output);
            }
            output += sizeof(uint8_t);
            output_length -= sizeof(uint8_t);
            r = _mutate_nonterm_19(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_19(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_3(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        case 5: {
            if (UNLIKELY(sizeof(uint8_t) > output_length)) {
                return output_length;
            }
            if (mutate) {
                _numberset_6(output);
            }
            output += sizeof(uint8_t);
            output_length -= sizeof(uint8_t);
            r = _mutate_nonterm_19(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_19(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_19(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_3(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        default: {
            __builtin_unreachable();
        }
    }
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal 'json::HEX-DIGIT'
static size_t _mutate_nonterm_4 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    (void) steps;
    unsigned int mutate;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    mutate = (s >= length);
    
    
    if (UNLIKELY(sizeof(uint8_t) > output_length)) {
        return output_length;
    }
    if (mutate) {   
        _numberset_0(output);
    }
    output += sizeof(uint8_t);
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal 'json::WS'
static size_t _mutate_nonterm_5 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    (void) steps;
    (void) length;
    (void) capacity;
    (void) step;
    (void) output;
    (void) output_length;
    return 0;
}

// This is the mutation function for non-terminal 'json::LEADING-DIGITS'
static size_t _mutate_nonterm_6 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    size_t r;
    unsigned int mutate;
    step_t rule;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    *step = s + 1;
    
    mutate = (s >= length);
    
    if (mutate) {
        rule = (step_t) TRIANGULAR_RANDOM(2);
        steps[s] = rule;
    } else {
        rule = steps[s];
    }
    
    switch (rule) {
        case 0: {
            if (UNLIKELY(sizeof(TERMINAL_3) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_3, sizeof(TERMINAL_3));
            }
            output += sizeof(TERMINAL_3);
            break;
        }
        
        case 1: {
            if (UNLIKELY(sizeof(uint8_t) > output_length)) {
                return output_length;
            }
            if (mutate) {
                _numberset_7(output);
            }
            output += sizeof(uint8_t);
            output_length -= sizeof(uint8_t);
            r = _mutate_nonterm_7(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        default: {
            __builtin_unreachable();
        }
    }
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal 'json::MORE-DIGITS'
static size_t _mutate_nonterm_7 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    size_t r;
    unsigned int mutate;
    step_t rule;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    *step = s + 1;
    
    mutate = (s >= length);
    
    if (mutate) {
        rule = (step_t) TRIANGULAR_RANDOM(2);
        steps[s] = rule;
    } else {
        rule = steps[s];
    }
    
    switch (rule) {
        case 0: {
            break;
        }
        
        case 1: {
            if (UNLIKELY(sizeof(uint8_t) > output_length)) {
                return output_length;
            }
            if (mutate) {
                _numberset_2(output);
            }
            output += sizeof(uint8_t);
            output_length -= sizeof(uint8_t);
            r = _mutate_nonterm_7(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        default: {
            __builtin_unreachable();
        }
    }
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal 'json::FRACTION'
static size_t _mutate_nonterm_8 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    size_t r;
    unsigned int mutate;
    step_t rule;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    *step = s + 1;
    
    mutate = (s >= length);
    
    if (mutate) {
        rule = (step_t) TRIANGULAR_RANDOM(2);
        steps[s] = rule;
    } else {
        rule = steps[s];
    }
    
    switch (rule) {
        case 0: {
            break;
        }
        
        case 1: {
            if (UNLIKELY(sizeof(TERMINAL_5) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_5, sizeof(TERMINAL_5));
            }
            output += sizeof(TERMINAL_5);
            output_length -= sizeof(TERMINAL_5);
            r = _mutate_nonterm_14(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        default: {
            __builtin_unreachable();
        }
    }
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal 'json::EXPONENT'
static size_t _mutate_nonterm_9 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    size_t r;
    unsigned int mutate;
    step_t rule;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    *step = s + 1;
    
    mutate = (s >= length);
    
    if (mutate) {
        rule = (step_t) LINEAR_RANDOM(3);
        steps[s] = rule;
    } else {
        rule = steps[s];
    }
    
    switch (rule) {
        case 0: {
            break;
        }
        
        case 1: {
            if (UNLIKELY(sizeof(TERMINAL_23) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_23, sizeof(TERMINAL_23));
            }
            output += sizeof(TERMINAL_23);
            output_length -= sizeof(TERMINAL_23);
            r = _mutate_nonterm_11(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_14(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        case 2: {
            if (UNLIKELY(sizeof(TERMINAL_22) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_22, sizeof(TERMINAL_22));
            }
            output += sizeof(TERMINAL_22);
            output_length -= sizeof(TERMINAL_22);
            r = _mutate_nonterm_11(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_14(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        default: {
            __builtin_unreachable();
        }
    }
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal '(group 2)'
static size_t _mutate_nonterm_10 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    size_t r;
    unsigned int mutate;
    step_t rule;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    *step = s + 1;
    
    mutate = (s >= length);
    
    if (mutate) {
        rule = (step_t) LINEAR_RANDOM(9);
        steps[s] = rule;
    } else {
        rule = steps[s];
    }
    
    switch (rule) {
        case 0: {
            if (UNLIKELY(sizeof(TERMINAL_6) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_6, sizeof(TERMINAL_6));
            }
            output += sizeof(TERMINAL_6);
            break;
        }
        
        case 1: {
            if (UNLIKELY(sizeof(TERMINAL_7) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_7, sizeof(TERMINAL_7));
            }
            output += sizeof(TERMINAL_7);
            break;
        }
        
        case 2: {
            if (UNLIKELY(sizeof(TERMINAL_8) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_8, sizeof(TERMINAL_8));
            }
            output += sizeof(TERMINAL_8);
            break;
        }
        
        case 3: {
            if (UNLIKELY(sizeof(TERMINAL_9) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_9, sizeof(TERMINAL_9));
            }
            output += sizeof(TERMINAL_9);
            break;
        }
        
        case 4: {
            if (UNLIKELY(sizeof(TERMINAL_10) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_10, sizeof(TERMINAL_10));
            }
            output += sizeof(TERMINAL_10);
            break;
        }
        
        case 5: {
            if (UNLIKELY(sizeof(TERMINAL_11) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_11, sizeof(TERMINAL_11));
            }
            output += sizeof(TERMINAL_11);
            break;
        }
        
        case 6: {
            if (UNLIKELY(sizeof(TERMINAL_12) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_12, sizeof(TERMINAL_12));
            }
            output += sizeof(TERMINAL_12);
            break;
        }
        
        case 7: {
            if (UNLIKELY(sizeof(TERMINAL_2) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_2, sizeof(TERMINAL_2));
            }
            output += sizeof(TERMINAL_2);
            break;
        }
        
        case 8: {
            if (UNLIKELY(sizeof(TERMINAL_13) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_13, sizeof(TERMINAL_13));
            }
            output += sizeof(TERMINAL_13);
            output_length -= sizeof(TERMINAL_13);
            r = _mutate_nonterm_4(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_4(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_4(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_4(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        default: {
            __builtin_unreachable();
        }
    }
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal '(group 4)'
static size_t _mutate_nonterm_11 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    unsigned int mutate;
    step_t rule;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    *step = s + 1;
    
    mutate = (s >= length);
    
    if (mutate) {
        rule = (step_t) LINEAR_RANDOM(3);
        steps[s] = rule;
    } else {
        rule = steps[s];
    }
    
    switch (rule) {
        case 0: {
            break;
        }
        
        case 1: {
            if (UNLIKELY(sizeof(TERMINAL_15) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_15, sizeof(TERMINAL_15));
            }
            output += sizeof(TERMINAL_15);
            break;
        }
        
        case 2: {
            if (UNLIKELY(sizeof(TERMINAL_14) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_14, sizeof(TERMINAL_14));
            }
            output += sizeof(TERMINAL_14);
            break;
        }
        
        default: {
            __builtin_unreachable();
        }
    }
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal '(group 1)'
static size_t _mutate_nonterm_15 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    size_t r;
    unsigned int mutate;
    step_t rule;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    *step = s + 1;
    
    mutate = (s >= length);
    
    if (mutate) {
        rule = (step_t) LINEAR_RANDOM(10);
        steps[s] = rule;
    } else {
        rule = steps[s];
    }
    
    switch (rule) {
        case 0: {
            if (UNLIKELY(sizeof(TERMINAL_19) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_19, sizeof(TERMINAL_19));
            }
            output += sizeof(TERMINAL_19);
            break;
        }
        
        case 1: {
            if (UNLIKELY(sizeof(TERMINAL_20) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_20, sizeof(TERMINAL_20));
            }
            output += sizeof(TERMINAL_20);
            break;
        }
        
        case 2: {
            if (UNLIKELY(sizeof(TERMINAL_18) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_18, sizeof(TERMINAL_18));
            }
            output += sizeof(TERMINAL_18);
            break;
        }
        
        case 3: {
            if (UNLIKELY(sizeof(TERMINAL_16) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_16, sizeof(TERMINAL_16));
            }
            output += sizeof(TERMINAL_16);
            output_length -= sizeof(TERMINAL_16);
            r = _mutate_nonterm_12(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        case 4: {
            if (UNLIKELY(sizeof(TERMINAL_17) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_17, sizeof(TERMINAL_17));
            }
            output += sizeof(TERMINAL_17);
            output_length -= sizeof(TERMINAL_17);
            r = _mutate_nonterm_13(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        case 5: {
            if (UNLIKELY(sizeof(TERMINAL_2) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_2, sizeof(TERMINAL_2));
            }
            output += sizeof(TERMINAL_2);
            output_length -= sizeof(TERMINAL_2);
            r = _mutate_nonterm_3(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        case 6: {
            if (UNLIKELY(sizeof(TERMINAL_17) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_17, sizeof(TERMINAL_17));
            }
            output += sizeof(TERMINAL_17);
            output_length -= sizeof(TERMINAL_17);
            r = _mutate_nonterm_5(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_17(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        case 7: {
            r = _mutate_nonterm_6(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_8(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_9(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        case 8: {
            if (UNLIKELY(sizeof(TERMINAL_16) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_16, sizeof(TERMINAL_16));
            }
            output += sizeof(TERMINAL_16);
            output_length -= sizeof(TERMINAL_16);
            r = _mutate_nonterm_5(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_16(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        case 9: {
            if (UNLIKELY(sizeof(TERMINAL_15) > output_length)) {
                return output_length;
            }
            if (mutate) {
                __builtin_memcpy(output, TERMINAL_15, sizeof(TERMINAL_15));
            }
            output += sizeof(TERMINAL_15);
            output_length -= sizeof(TERMINAL_15);
            r = _mutate_nonterm_6(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_8(steps, length, capacity, step, output, output_length);
            output += r;
            output_length -= r;
            r = _mutate_nonterm_9(steps, length, capacity, step, output, output_length);
            output += r;
            break;
        }
        
        default: {
            __builtin_unreachable();
        }
    }
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal '(terminal:0)'
static size_t _mutate_nonterm_16 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    (void) steps;
    unsigned int mutate;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    mutate = (s >= length);
    
    
    if (UNLIKELY(sizeof(TERMINAL_0) > output_length)) {
        return output_length;
    }
    if (mutate) {   
        __builtin_memcpy(output, TERMINAL_0, sizeof(TERMINAL_0));
    }
    output += sizeof(TERMINAL_0);
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal '(terminal:1)'
static size_t _mutate_nonterm_18 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    (void) steps;
    unsigned int mutate;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    mutate = (s >= length);
    
    
    if (UNLIKELY(sizeof(TERMINAL_21) > output_length)) {
        return output_length;
    }
    if (mutate) {   
        __builtin_memcpy(output, TERMINAL_21, sizeof(TERMINAL_21));
    }
    output += sizeof(TERMINAL_21);
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal '(terminal:2)'
static size_t _mutate_nonterm_17 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    (void) steps;
    unsigned int mutate;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    mutate = (s >= length);
    
    
    if (UNLIKELY(sizeof(TERMINAL_1) > output_length)) {
        return output_length;
    }
    if (mutate) {   
        __builtin_memcpy(output, TERMINAL_1, sizeof(TERMINAL_1));
    }
    output += sizeof(TERMINAL_1);
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal '(terminal:3)'
static size_t _mutate_nonterm_19 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    (void) steps;
    unsigned int mutate;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    mutate = (s >= length);
    
    
    if (UNLIKELY(sizeof(uint8_t) > output_length)) {
        return output_length;
    }
    if (mutate) {   
        _numberset_1(output);
    }
    output += sizeof(uint8_t);
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal 'json::VALUE'
static size_t _mutate_nonterm_20 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    (void) steps;
    size_t r;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    
    r = _mutate_nonterm_15(steps, length, capacity, step, output, output_length);
    output += r;
    output_length -= r;
    r = _mutate_nonterm_5(steps, length, capacity, step, output, output_length);
    output += r;
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal 'json::OBJECT-SEQUENCE'
static size_t _mutate_nonterm_12 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    (void) steps;
    size_t r;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    
    r = _mutate_nonterm_2(steps, length, capacity, step, output, output_length);
    output += r;
    output_length -= r;
    r = _mutate_nonterm_5(steps, length, capacity, step, output, output_length);
    output += r;
    output_length -= r;
    r = _mutate_nonterm_18(steps, length, capacity, step, output, output_length);
    output += r;
    output_length -= r;
    r = _mutate_nonterm_20(steps, length, capacity, step, output, output_length);
    output += r;
    output_length -= r;
    r = _mutate_nonterm_0(steps, length, capacity, step, output, output_length);
    output += r;
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal 'json::ARRAY-SEQUENCE'
static size_t _mutate_nonterm_13 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    (void) steps;
    size_t r;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    
    r = _mutate_nonterm_15(steps, length, capacity, step, output, output_length);
    output += r;
    output_length -= r;
    r = _mutate_nonterm_5(steps, length, capacity, step, output, output_length);
    output += r;
    output_length -= r;
    r = _mutate_nonterm_1(steps, length, capacity, step, output, output_length);
    output += r;
    
    return (size_t) (output - original_output);
}

// This is the mutation function for non-terminal 'json::DIGITS'
static size_t _mutate_nonterm_14 (step_t* steps, const size_t length, const size_t capacity, size_t* step, unsigned char* output, size_t output_length)  {
    (void) steps;
    size_t r;
    unsigned int mutate;
    unsigned char* original_output = output;
    size_t s = *step;
    
    if (UNLIKELY(s >= capacity)) {
        return output_length;
    }
    mutate = (s >= length);
    
    
    if (UNLIKELY(sizeof(uint8_t) > output_length)) {
        return output_length;
    }
    if (mutate) {   
        _numberset_2(output);
    }
    output += sizeof(uint8_t);
    output_length -= sizeof(uint8_t);
    r = _mutate_nonterm_7(steps, length, capacity, step, output, output_length);
    output += r;
    
    return (size_t) (output - original_output);
}

#endif /* !defined(OMIT_CHAMELEON_MUTATE) || !defined(OMIT_CHAMELEON_GENERATE) */

#ifndef OMIT_CHAMELEON_SEED
EXPORT_FUNCTION
void chameleon_seed (size_t new_seed) {
    if (new_seed != 0) {
        rand_state = new_seed;
    } else {
        rand_state = CHAMELEON_SEED;
    }
}
#endif /* OMIT_CHAMELEON_SEED */

#ifndef OMIT_CHAMELEON_INIT
EXPORT_FUNCTION
void chameleon_init (ChameleonWalk* walk, size_t capacity) {
    walk->steps = malloc(capacity * sizeof(step_t));
    walk->length = 0;
    walk->capacity = capacity;
}
#endif /* OMIT_CHAMELEON_INIT */

#ifndef OMIT_CHAMELEON_DESTROY
EXPORT_FUNCTION
void chameleon_destroy (ChameleonWalk* walk) {
    free(walk->steps);
    __builtin_memset(walk, 0, sizeof(ChameleonWalk));
}
#endif /* OMIT_CHAMELEON_DESTROY */

#ifndef OMIT_CHAMELEON_MUTATE
EXPORT_FUNCTION
size_t chameleon_mutate (ChameleonWalk* walk, unsigned char* output, size_t output_length) {
    size_t length = 0;
    if (LIKELY(walk->length > 0)) {
        length = LINEAR_RANDOM(walk->length);
        walk->length = 0;
    }
    return _mutate_nonterm_20(walk->steps, length, walk->capacity, &walk->length, output, output_length);
}
#endif /* OMIT_CHAMELEON_MUTATE */

#ifndef OMIT_CHAMELEON_GENERATE
EXPORT_FUNCTION
size_t chameleon_generate (ChameleonWalk* walk, unsigned char* output, size_t output_length) {
    walk->length = 0;
    return _mutate_nonterm_20(walk->steps, 0, walk->capacity, &walk->length, output, output_length);
}
#endif /* OMIT_CHAMELEON_GENERATE */